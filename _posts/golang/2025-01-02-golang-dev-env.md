---
layout: single
title: "Go 언어 개발환경 구성하기"
date: 2025-01-02 17:00:00 +0900
categories: 
  - Go
tag: 
  - Golang
toc: true
toc_label: 목차
toc_sticky: true
---

본 포스트는 **Windows** 환경에서 Go 언어 개발 환경을 구성하는 방법을 설명한 것 입니다.

Java에 익숙한 개발자를 위해서 작성된 포스트입니다. 

# Go 언어?

Go 언어, 또는 Golang 이라고 부르는 개발 언어는 2009년 구글에서 개발된 오픈 소스 프로그래밍 언어입니다.

Go 언어는 Java 와 마찬가지로 범용 언어이지만, 특히 **동시성(concurrency), 성능, 간결성**에 중점을 두고 개발된 언어입니다. 

# Java와 Go의 주요 차이점

## 런타임 환경

* Java
  * Java는 JVM(Java Virtual Machine) 위에서 실행되며, 플랫폼 독립성을 제공합니다.
  * 하지만 JVM은 비교적 무겁고, 시작 속도가 느릴 수 있습니다.
* Go
  * Go는 컴파일된 바이너리로 실행되며, 별도의 런타임 환경(JVM)이 필요 없습니다. 
  * 이는 실행 속도가 빠르고, 배포가 간단하다는 장점이 있습니다.

## 문법과 간결성

* Java
  * Java는 객체지향 프로그래밍(OOP)을 기반으로 하며, 클래스, 상속, 인터페이스 등 복잡한 구조를 가지고 있습니다.
* Go
  * Go는 간결한 문법을 가지고 있으며, 클래스나 상속이 없습니다. 
  * 대신, **구조체(struct)**와 **인터페이스(interface)**를 사용합니다. 
  * 코드가 단순하고 비교적 읽기 쉽습니다. 

## 동시성(concurrency)

* Java
  * Java는 'Thread'와 'ExecutorService'를 사용하여 동시성을 구현합니다.
* GO
  * **고루틴(goroutine)**과 **채널(channel)**을 사용하여 동시성을 간단하고 효율적으로 처리합니다.
  * 고루틴은 스레드에 비해 매우 가벼워서, 수천 개의 고루틴을 실행해도 성능에 큰 영향을 주지 않습니다.

## 가비지 컬렉션(Garbage Collection)

* Java
  * Java는 JVM에서 가비지 컬렉션을 자동으로 처리합니다.
* GO
  * Go도 가비지 컬렉션을 지원하지만, 더 간단하고 효율적인 방식으로 동작합니다. 
  * 메모리 관리를 신경 쓸 필요가 없다는 점은 Java와 유사합니다.

## 패키지 관리

* Java
  * Java는 Maven, Gradle과 같은 빌드 도구를 사용하여 의존성을 관리합니다.
* Go
  * Go는 내장된 **go mod**를 사용하여 의존성을 관리합니다.

## 객체 지향 프로그래밍(OOP)

* Java
  * Java는 전통적인 객체지향 언어로, 클래스와 상속을 중심으로 설계됩니다.
* Go
  * Go는 객체지향 언어는 아니지만, 구조체와 인터페이스를 통해 객체지향적인 설계를 지원합니다.
  * 다중 상속은 지원하지 않으며, 대신 **구성(Composition)**을 권장합니다.

## 에러 처리

* Java
  * Java는 예외를 클래스의 형태로 정의하고, try-catch 블록을 사용하여 예외를 처리합니다.
* Go
  * Go는 예외 처리 대신 **에러를 값으로 취급**합니다. 
  * 함수는 일반적으로 두 개의 반환 값을 가지며, 첫 번째는 결과 값이고 두 번째는 에러입니다.

# Go 개발 환경 구성

## Go 설치

[Go 언어 공식 사이트](https://go.dev/dl/)에서 사용할 Go 버전을 다운로드 받아서 설치합니다.

설치 후에 터미널에서 `go version` 명령을 입력해서 설치가 정상적으로 완료됐는지 확인합니다.

```
C:\>go version
go version go1.20.12 windows/amd64
```

## 환경 변수 설정

Go 언어는 몇 가지 중요한 환경 변수를 사용하는데, 이 변수들은 Go 언어의 동작 방식과 프로젝트 구조에 큰 영향을 줍니다.

터미널에서 `go env` 명령으로 Go 언어의 환경 변수를 확인합니다.

```
C:\>go env
set GOROOT=C:\programs\Go
set GOPATH=C:\workspace\gopath
set GOBIN=
set GOARCH=amd64
set GOOS=windows
...
```

* 주요 환경 변수
  * GOROOT
    * Go 언어가 설치된 디렉토리입니다.
    * 일반적으로 설치 시 자동으로 설정됩니다.
  * GOPATH
    * 개발하는 Go 프로젝트에서 import할 모듈들이 설치되고 관리될 경로를 지정합니다.
  * GOBIN
    * Go 바이너리 파일이 설치될 디렉토리를 지정합니다.
    * 특정 디렉토리를 설정하지 않으면 Go에서 생성된 바이너리 파일은 **'$GOPATH/bin'** 디렉토리에 생성됩니다.
  * GOARCH
    * Go 프로그램이 빌드될 대상 시스템의 아키텍처를 지정합니다.
    * 이 환경 변수는 CPU 아키텍처에 따라 다르게 설정됩니다.
      * **amd64**: 64비트 Intel/AMD 프로세서
      * **arm64**: 64비트 ARM 프로세서
    * 이 환경 변수를 이용하면 Go 언어의 크로스 컴파일 기능을 활용하여 'amd64' 아키텍처 환경에서도 'arm64'를 위한 바이너리 파일을 만들 수 있습니다.   
  * GOOS
    * Go 프로그램이 실행될 대상 운영 체제를 지정합니다.
    * 이 환경 변수는 운영 체제에 따라 다르게 설정됩니다.
      * **linux**: 리눅스 운영 체제
      * **windows**: 윈도우 운영 체제
      * **darwin**: macOS
      * freebsd, openbsd, netbsd 등 다양한 운영 체제도 지원합니다.
    * 이 환경 변수를 이용하면 Go 언어의 크로스 컴파일 기능을 활용하여 'Windows'에서도 'Linux'를 위한 바이너리 파일을 만들 수 있습니다.

# Go 언어 의존성 관리

Go 언어 1.10 버전까지는 환경 변수 **'GOPATH'**에 정의된 경로에서만 의존성을 관리했습니다. ($GOPATH/src 디렉토리에서만 프로젝트를 생성할 수 있었음)

Go Mudules가 Go 1.11 버전부터 옵션 기능으로 등장했다가 Go 1.13 버전부터는 디렉토리에 **'go.mod'** 파일이 있으면 기본적으로 모듈 모드로 동작하게 되었습니다.

Go Modules는 간단히 생각하면 Go 언어가 의존성을 관리하는 방법으로 Java의 Maven과 유사합니다.

## GOPATH vs Go Module

Go 언어로 개발되는 여러 프로젝트들을 $GOPATH 단일 경로로 관리하면 각 프로젝트 의존성 패키지가 섞이면서 관리가 힘들어집니다.

Go Modules를 사용하면 프로젝트 별로 의존성 관리를 할 수 있기 때문에 Go 1.13 이후를 사용하는 프로젝트는 Go Modules로 의존성을 관리합니다.

## Go Modules 기본 개념

* **모듈**
  * Go 모듈은 관련된 Go 패키지의 집합으로, **'go.mod'** 파일을 통해 정의됩니다.
  * **'go.mod'** 파일이 있는 곳이 모듈의 root가 됩니다.
  * **'go.mod'** 파일은 모듈의 이름, Go 버전, 의존성 목록 등을 포함하며, Maven의 pom.xml과 유사한 역할을 하는 파일입니다.
* **의존성 관리**
  * Go Modules는 외부 패키지의 버전을 명시적으로 관리할 수 있으며, 필요한 패키지를 쉽게 추가하거나 업데이트할 수 있습니다.
  * Maven의 의존성 관리와 유사하게, Go Modules도 의존성을 자동으로 해결하고 관리합니다.

## Go Modules와 프로젝트 구조

Go 모듈은 특정 디렉토리에서 시작되며, 이 디렉토리에는 **'go.mod'** 파일이 위치합니다.

즉, **'go.mod'** 파일이 있는 디렉토리는 모듈의 루트가 되며, 하위 디렉토리에는 관련 패키지가 포함될 수 있습니다.

예를 들어, 다음과 같은 구조를 가진 프로젝트에서 **'my_project'**는 모듈의 루트이며, 
**'agent'** 나 **'apiclient'** 디렉토리는 하위 패키지를 포함합니다. 그리고 **'app.go'** 파일은 모둘의 진입점이 됩니다.

```
my_project/
+--- go.mod
+--- go.sum
+--- app.go
+--- agent/
|   +--- agent_server.go
|   +--- config_manager.go
+--- apiclient/
|   +--- remote-api-endpoints.go
```

## Go Modules 사용 방법

### 모듈 초기화

새로운 Go 프로젝트를 시작한다면 먼저 모듈을 초기화해야 합니다.

예를 들어, 'example.com/myproject'라는 모듈을 생성한다면 다음과 같이 입력합니다.

```
go mod init example.com/myproject
```

이런 명령을 실행하면 'go.mod' 파일이 생성되는데, 이 파일은 Maven의 pom.xml 처럼 프로젝트의 메타데이터와 의존성을 관리합니다.

### 의존성 추가

프로젝트에서 외부 패키지를 사용하려면, 해당 패키지를 import하고 **'go build'** 또는 **'go run'** 명령어를 실행하면 Go가 자동으로 **'go.mod'** 파일에 의존성을 추가합니다. 

예를 들어, github.com/gorilla/mux 패키지를 사용하려면 다음과 같이 코드를 작성합니다.

```
import "github.com/gorilla/mux"
```

코드를 작성한 후에 **'go run'** 명령을 실행하면 Go 언어가 해당 패키지를 다운로드하고 **'go.mod'** 파일에 추가합니다.

이 작업은 Maven의 'mvn install'과 유사한 방식입니다.

### 의존성 관리 명령어

Go Modules에서는 여러 가지 유용한 명령어를 제공합니다.

* **'go mod tidy'**
  * 사용하지 않는 의존성을 추가하고, 필요한 의존성을 추가합니다. 
  * Maven의 'mvn dependency:purge-local-repository'와 비슷한 역할을 합니다.
* **'go get'**
  * 특정 패키지를 추가하거나 업데이트할 때 사용합니다. 
  * 예를 들어, 특정 버전의 패키지를 설치하려면 `go get github.com/gorilla/mux@v1.8.0`와 같이 입력합니다.

### go.sum 파일

**'go.sum'** 파일은 의존성의 해시 값을 저장하여 의존성의 무결정을 보장합니다.

이 파일은 **'go.mod'**와 함께 자동으로 생성되며, 의존성이 변조되지 않았음을 확인하는 데 사용됩니다. 

Maven의 'dependency:tree'와 유사한 역할을 합니다.

# Go 빌드하기

## go build

Go 프로그램을 빌드하려면 **'go build'** 명령을 사용합니다. 

이 명령어는 현재 디렉토리의 Go 소스 파일을 컴파일하여 실행 가능한 바이너리 파일을 생성합니다.

기본적인 사용법은 다음과 같습니다.

```
go build [패키지이름]
```

만약 패키지이름을 생략하면 현재 디렉토리의 모든 Go 파일이 빌드됩니다.

빌드된 바이너리는 현재 디렉토리에 생성됩니다.

예를 들어, **'app.go'** 파일이 있는 디렉토리에서 `go build` 명령을 실행하면 **'app'**이라는 실행 파일이 생성됩니다.

## 주요 빌드 옵션

다음은 `go build` 명령에서 자주 사용되는 옵션들 입니다.

* **-o 파일명**: 생성할 출력 파일의 이름을 지정합니다. 예를 들어, `go build -o myapp`는 `myapp`이라는 이름의 실행 파일을 생성합니다.
* **-v**: 빌드 과정에서 어떤 패키지가 빌드되고 있는지에 대한 자세한 정보를 출력합니다. 이 옵션을 사용하면 빌드 진행 상황을 쉽게 확인할 수 있습니다.
* **-i**: 패키지의 의존성을 설치합니다. 이 옵션을 사용하면 패키지가 변경되지 않는 한, 다음 빌드 시 의존성을 다시 설치하지 않습니다.
* **-x**: 빌드 과정에서 실행되는 명령어를 출력합니다. 이 옵션은 빌드 과정에서 어떤 명령이 실행되는지 확인할 수 있어 디버깅에 유용합니다.
* **-ldflags**: 링커에 전달할 추가 플래그를 설정합니다. 이 옵션을 사용하여 바이너리의 최적화를 수행하거나, 특정 변수를 설정할 수 있습니다. 예를 들어, -ldflags="-s -w"는 디버그 정보를 제거하여 바이너리 크기를 줄입니다.
* **-tags**: 빌드 시 사용할 태그를 지정합니다. 이 옵션은 특정 기능을 활성화하거나 비활성화하는 데 사용됩니다. 예를 들어, -tags=release는 릴리스 빌드를 위한 태그를 설정할 수 있습니다.
* **-buildvcs**: Go 1.18에서 도입된 옵션으로 바이너리에 버전 관리 시스템(VCS) 정보를 포함할지 여부를 결정합니다. (auto, true, false 중 하나)

## IDE에서 Go 프로젝트 Run Configuration

다음 이미지는 IntelliJ 에서 Go 프로젝트의 Run/Debug Configuration을 설정한 예 입니다.

![IntelliJ 에서 Go 프로젝트의 Run/Debug Configuration](/assets/images/post/golang/2025-01-02-golang-dev-env/intellij_run_config.png)

# 참고

[Go의 의존성 관리](https://velog.io/@ymlee3218/Go%EC%9D%98-%EC%9D%98%EC%A1%B4%EC%84%B1-%EA%B4%80%EB%A6%AC)
