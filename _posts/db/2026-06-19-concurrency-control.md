---
layout: single
title: "DBMS Lock과 Latch: 엔지니어를 위한 가이드"
date: 2025-06-19 14:00:00 +0900
categories: 
  - internal
tag: 
  - 동시성제어
  - 공유자원
  - concurrency
  - lock
  - latch
  - mutex
  - semaphore
toc: true
toc_label: 목차
toc_sticky: true
---

"시스템이 갑자기 느려졌어요!" DBMS 엔지니어가 가장 자주 마주하는 상황입니다. 원인을 찾아 시스템을 깊숙이 들여다보면 `Lock`, `Latch`, `Mutex`, `Semaphore` 같은 낯선 용어들이 나타나 성능 분석을 가로막곤 합니다. 이들은 모두 **동시성 제어**라는 하나의 목표를 위해 존재하지만, 역할과 작동 레벨이 완전히 다릅니다.

이들을 명확히 구분하지 못하면, **애플리케이션 문제(Lock)**를 **DB 내부 문제(Latch)**로 오인하여 엉뚱한 곳에서 시간을 허비하게 됩니다. 이 문서는 이 중요한 개념들의 차이를 명확히 이해하기 위해 작성되었습니다.

## 가장 중요한 첫걸음: Lock vs. Latch

가장 먼저 `Lock`과 `Latch`의 근본적인 차이를 이해해야 합니다. 이것이 동시성 문제 분석의 첫 단추입니다.

- **Lock (락)**: **데이터의 논리적 일관성을 위한 잠금**입니다. 여러 사용자가 동시에 같은 데이터에 접근하여 값이 뒤섞이거나 부정확해지는 것을 막는 것이 주 목적입니다. 이는 **트랜잭션**이라는 논리적 작업 단위와 밀접하게 관련 있으며, 트랜잭션이 시작되고 끝나는 긴 시간 동안 유지될 수 있습니다.
    - **주요 종류**:
        - **Shared Lock (공유 락, S-Lock)**: 데이터를 '읽기' 위한 락입니다. 다른 사용자가 동시에 데이터를 읽는 것(또 다른 S-Lock)은 허용하지만, 데이터를 변경하는 것(X-Lock)은 막습니다.
        - **Exclusive Lock (배타 락, X-Lock)**: 데이터를 '쓰기(수정/삭제)' 위한 락입니다. 이 락이 걸리면 다른 어떤 사용자도 해당 데이터를 읽거나 쓸 수 없습니다.
    - **문제 상황**: 여러 트랜잭션이 서로 필요한 리소스에 X-Lock을 건 채 상대방이 끝나기만을 기다리는 **교착 상태(Deadlock)**가 대표적인 Lock 관련 문제입니다.

- **Latch (래치)**: **메모리 구조의 물리적 무결성을 위한 잠금**입니다. DBMS는 SQL을 처리하기 위해 버퍼 캐시, 로그 버퍼 등 수많은 내부 메모리 구조를 사용합니다. 여러 스레드가 이 공유 메모리 구조에 동시에 접근하여 연결 리스트가 끊어지거나 카운트가 틀리는 등의 파괴적인 상황을 막기 위해 사용됩니다. '빗장'이나 '걸쇠'처럼, 마이크로초(µs) 단위의 아주 짧은 시간 동안만 빠르게 점유하고 해제하는 매우 가벼운 잠금입니다.

| 구분 | **논리적 Lock (Transactional Lock)** | **물리적 Latch (Internal Lock)** |
|:---:|---|---|
| **수준** | 고수준 (High-Level), **애플리케이션 논리** | 저수준 (Low-Level), **DBMS 엔진 내부** |
| **목적** | 트랜잭션의 **데이터 일관성** 보호 (ACID 속성) | 공유 **메모리 자료구조**의 물리적 보호 |
| **대상** | 테이블, 페이지, 행(Row) 등 논리적 데이터 단위 | 버퍼 캐시, 인덱스 노드, 프로세스 리스트 등 내부 메모리 구조 |
| **지속 시간** | 비교적 김 (트랜잭션 단위, 밀리초 이상) | 매우 짧음 (특정 내부 작업 단위, 마이크로초 이하) |
| **데드락** | 발생 가능하며, DBMS가 감지하고 해제함 | 일반적으로 발생하지 않도록 설계됨 (발생 시 버그) |
| **분석 초점** | 애플리케이션 로직, 트랜잭션 설계, SQL 쿼리 | DBMS 내부 리소스 경합, 하드웨어 성능, 버그 |

## Latch 용어의 두 얼굴: 일반 DBMS vs. Oracle

`Latch`는 대부분의 DBMS와 Oracle에서 서로 다른 무게감으로 사용됩니다. 이 차이를 이해하면 특정 DBMS의 문서를 볼 때 혼란을 피할 수 있습니다.

### 일반 DBMS (SAP HANA 등)에서의 'Latch'

일반적인 DBMS에서 `Latch`는 **개념적이고 포괄적인 용어**입니다. 논리적 `Lock`과 대비되는 개념으로, DBMS 내부의 공유 메모리를 보호하는 **모든 종류의 짧고 빠른 물리적 잠금**을 통칭합니다.

여기서 중요한 것은 **'정책'과 '구현'의 분리**입니다.
- **Latch (정책, What)**: "버퍼 캐시의 연결 리스트를 보호해야 한다"는 **정책 또는 목표**
- **Mutex/Semaphore (구현, How)**: 위 정책을 실현하기 위해 사용하는 **프로그래밍 도구**

즉, SAP HANA와 같은 시스템에서 "Latch 경합이 발생했다"라고 말한다면, 이는 "DBMS 내부의 특정 메모리 영역에서 병목이 발생했다"는 의미로 해석할 수 있습니다.

> **한 줄 요약**: DBMS 내부 메모리 보호를 위한 **저수준 물리적 잠금이라는 개념(Concept) 그 자체.**

### Oracle DBMS에서의 'Latch'

반면 Oracle에서 `Latch`는 더 **구체적이고 한정적인 객체**를 지칭합니다. Oracle은 성능 최적화를 위해 저수준 잠금을 기능별로 세분화했는데, `Latch`는 그중 하나일 뿐입니다.

Oracle의 `Latch`는 주로 SGA 내의 **상대적으로 무겁고 복잡한 메모리 구조(예: 버퍼 캐시 체인, 리두 버퍼)**를 보호하는 데 사용됩니다. 이는 라이브러리 캐시의 SQL 커서처럼 가볍고 접근 빈도가 매우 높은 객체를 보호하는 `Mutex`와 명확히 구분됩니다. 따라서 Oracle에서 `Latch`와 `Mutex`는 **상하 관계가 아닌, 서로 다른 목적을 가진 대등한 레벨의 잠금 메커니즘**입니다.

> **한 줄 요약**: SGA의 특정 메모리 구조를 보호하는, **`Mutex`와는 다른 목적을 가진 구체적인 잠금 객체(Object).**

### 왜 Oracle만 'Latch'의 의미가 다를까?

이 차이는 Oracle의 긴 역사에서 비롯됩니다. 초창기 Oracle은 `Latch`라는 단일화된 방식으로 모든 내부 메모리 구조를 보호했습니다. 하지만 멀티코어 CPU가 보편화되자, 모든 저수준 잠금을 `Latch` 하나로 처리하는 방식은 심각한 성능 병목(Contention)을 유발했습니다.

특히 SQL 파싱처럼 매우 짧고 빈번하게 발생하는 작업을 처리할 때, 상대적으로 무거운 `Latch`를 사용하는 것은 비효율적이었습니다. 이 문제를 해결하기 위해 Oracle은 `Latch`보다 훨씬 가볍고 빠른 새로운 잠금 방식인 `Mutex`(Mutexes)를 개발하여 라이브러리 캐시 보호 등에 적용했습니다.

기존의 `Latch`는 버퍼 캐시처럼 무거운 데이터 구조를 보호하는 데 여전히 중요했으므로, `Latch`는 그대로 유지하면서 새로운 목적의 `Mutex`를 추가하는 방식으로 진화하게 된 것입니다. 이러한 역사적 배경 때문에 Oracle에서 `Latch`는 저수준 잠금 전체를 뜻하는 개념이 아닌, **`Mutex`와는 다른 목적을 가진 특정 잠금 객체**로 의미가 분화되었습니다.

## Mutex와 Semaphore: 더 깊이 이해하기

`Mutex`와 `Semaphore`는 운영체제와 프로그래밍에서 유래한 동기화 도구입니다. DBMS의 컨텍스트에서 이들의 역할을 다시 정리해 보겠습니다.

### 일반적인 DBMS (SAP HANA 등)

이 환경에서 `Mutex`와 `Semaphore`는 `Latch`라는 정책을 구현하는 핵심 부품입니다.

- **Mutex (Mutual Exclusion)**: 가장 흔한 잠금 도구로, '상호 배제'를 의미합니다. **오직 하나의 스레드**만 공유 자원에 접근하도록 허용하며, '1인용 화장실 열쇠'와 같습니다. 스레드가 Mutex를 획득하려 할 때, 짧은 시간 동안 CPU를 사용하며 락이 풀리는지 확인하다가(Spinning), 일정 시간이 지나도 풀리지 않으면 CPU를 반납하고 대기 상태로 들어갑니다(Sleep).
- **Semaphore**: `Mutex`보다 유연한 도구로, 두 가지 주요 용도로 사용됩니다.
    1.  **카운팅 세마포어**: **지정된 숫자(N)만큼**의 스레드가 동시에 자원에 접근하도록 허용합니다. 'N개의 키가 있는 다목적실'처럼, 리소스 풀을 관리하는 데 유용합니다.
    2.  **신호(Signaling) 메커니즘**: 스레드 간의 실행 순서를 제어합니다. 예를 들어, '생산자' 스레드가 작업을 완료한 후 '소비자' 스레드에게 "이제 작업해도 돼"라는 신호(post)를 보내면, 대기하던(wait) '소비자' 스레드가 깨어나 작업을 이어갑니다.

### Oracle DBMS

Oracle에서 이들의 위상은 조금 다릅니다.

- **Mutex**: 단순한 구현 도구를 넘어, `Latch`와 대등한 **독립적인 초경량 잠금 객체**입니다. `Latch`보다 훨씬 적은 메모리를 사용하고 CPU 명령어를 통해 빠르게 처리되도록 최적화되어, 라이브러리 캐시(SQL 커서)처럼 접근 빈도가 극도로 높은 자원을 보호하는 데 특화되어 있습니다.
- **Semaphore**: 사용자가 직접 튜닝하는 '잠금'이라기보다는, **내부 프로세스와 스레드의 흐름을 제어하는 신호 체계**의 성격이 강합니다. `Latch`나 `Mutex`를 획득하지 못한 스레드를 효율적으로 잠들게(sleep)하고, 락이 해제되었을 때 다시 깨워주는(wakeup/post) 역할을 담당합니다. 즉, 잠금 자체보다는 잠금을 기다리는 동안의 자원 관리에 더 집중합니다.

## 실전 응용: 모니터링 정보 해석하기 (SAP HANA 기준)

이제 배운 개념을 일반적인 DBMS를 기준으로 실제 상황에 적용해 보겠습니다. SAP HANA 시스템 모니터링 중 아래와 같은 스레드 정보를 발견했다고 가정해 봅시다.

- `Thread Type`: `SqlExecutor` **(SQL 실행기)**
- `Thread State Class`: `Record Lock` **고수준 원인 (High-Level Why)**
- `Thread State`: `Semaphore Wait` **저수준 상태 (Low-Level How)**

이 정보를 어떻게 해석해야 할까요?

1. **원인 파악**: `Thread State Class`가 `Record Lock`인 것을 보고, 이 스레드는 **논리적인 데이터 락(Lock) 때문에 멈춰있다**는 것을 알 수 있습니다. 즉, 다른 트랜잭션이 점유한 특정 데이터 행에 접근하지 못하고 있는 것입니다.
2. **상태 분석**: `Thread State`가 `Semaphore Wait`인 것을 보고, DBMS가 이 스레드를 무작성 대기시키는 것이 아니라 **내부 매커니즘(Latch)인 세마포어(Semaphore)를 사용해서 효율적인 대기 상태로 전환**시켰음을 알 수 있습니다.

**종합 해석**: 이 SQL 스레드는 **고수준의 논리적인 이유(Record Lock)** 때문에 작업을 진행하지 못하고 있으며, 이 대기 상태는 **저수준의 물리적인 매커니즘(Semaphore)**을 통해 관리되고 있다.

## 마무리

`Lock`, `Latch`, `Mutex`, `Semaphore`는 모두 동시성 제어를 위한 중요한 메커니즘이지만, 그 레벨과 목적은 명확히 구분됩니다.

- **`Lock`은 데이터의 문제, `Latch`는 DBMS 엔진의 문제.**
- **`Lock` 경합은 애플리케이션 로직을, `Latch` 경합은 SQL 성능과 DB 내부 구조를 봐야 한다.**

이 명확한 구분을 통해 문제의 진짜 원인이 어디에 있는지 파악할 수 있습니다.
